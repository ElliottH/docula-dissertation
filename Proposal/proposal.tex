\section{Introduction: The Problem To Be Addressed}

In the development and maintenance of software, especially those
containing large amounts of code, documentation frequently becomes a
problem. Often documentation is written separately from the code
itself, and as such the two diverge over time, leaving maintainers
worse off than if they'd never checked both in the first place. It is
the aim of this project to tackle this problem and to facilitate not
only the writing of correct and thorough documentation, but also the
easy maintenance of both code and documentation; this is to be
achieved by defining a syntax to interleave code with documentation,
so that both are kept together and are more easily kept in
synchronisation with one another.

It is important to distinguish between the two types of documentation
that occur in software development.\footnote{The naming of these is
purely of my own invention, and as far as I'm aware is not part of any
established convention; I will, however, be using these names
throughout.} Together, these two types of documentation should
describe a piece of software thoroughly:

\begin{description}
\item[Interface documentation] essentially defines a contract with the
  outside world as to what this function or class does, what it
  expects as input to give a valid output, what may (or may not)
  happen when given invalid inputs, and so on.

  It is important that \emph{interface documentation} be well-defined,
  as it is what informs another developer now or in the future as to
  what the function is \emph{supposed} to do.

\item[Implementation documentation] is essentially the comments that
  developers put (or rather, should put) into their code that explains
  \emph{how} and \emph{why} they are doing things the way they're
  doing them. These comments should be written with the expectation
  that someone else in the future may actually be using them to track
  down the relevant piece of code they looking to fix or update, as
  such they should be written as proper sentences and written in such
  a way that the comments can be combined into a full document that
  talks its way through the function.

  The \emph{implementation documentation} does not need to be as
  strictly defined as the \emph{interface documentation}, as it is
  more a process of describing the choices made in writing the
  function, rather than its intended use.
\end{description}

For an engine such as this to be useful and practical, all
language-specific input \& output should be separated from the
processing as far as is possible; as such, this project will be highly
modular in nature. It is my intention to split the project into three
sections: input parsing, processing and output formatting; this will
allow new modules for different source languages to be written without
affecting the any other languages, and the same with various output
formats (e.g. \LaTeX, HTML).

\pagebreak

\section{Starting Point}

Several other documentation engines exist, such as Doxygen \& Javadoc,
however none of them seem to account for the two distinct types of
documentation that exist within a code base. I have used both Doxygen
\& Javadoc to document projects in the past, and so I am familiar with
the style in which the comments used for the documentation are
written.

Since there is already wide use of these, particularly Doxygen, I will
be designing my syntax to be as compatible with theirs as
possible. This will allow users to easily switch between the two and
allow for increased uptake of the engine.

\section{Resources Required}

I shall be primarily be using my own computer for the development of
this project, which is currently a laptop running Mac OS X; I will
also be using the PWF machines, to ensure that the software produced
runs across a variety of UNIX-like operating systems. The project
shall be backed up to a git repository on BitBucket, and also to the
PWF.

I require no other special resources.

\section{Work to be done}

The project is made up of four main components:

\begin{enumerate}

\item Define a format of comment that is to be used for documentation
  and create a parser for it. This will involve designing the comment
  format to be as compatible with Doxygen's style as far as possible.
\item Produce the main processing component of the system, that will
  convert parsed data from an input module and transform it into a
  data structure that contains the documentation in an output format
  agnostic format.
\item Write an output module to take the documentation data and
  transform it into a human readable document.
\item Create a command line interface \& configuration file format to
  allow for tuning of the processing/output.
\end{enumerate}

\section{Success Criterion for the Main Result}

In order to evaluate the project, I shall be testing the software by
running it over the code bases of real world open-source projects that
already contain a Doxygen-style documentation comments and examining
the outputted documentation.

As part of this, Dr.~Watts has agreed that I may test it on some of
the open-source code developed by his company, I will then be able to
survey the writers of the source code to collect their opinions on the
output and examine the results.

\section{Possible Extensions}

\begin{itemize}
\item Given that the software will be designed to be highly modular,
  the input module could be adapted into a plug-in for a text editor
  that highlights discrepancies between documentation and code. For
  example if the documentation defines a different number of arguments
  from the function prototype, highlighting it appropriately.
\item Using LLVM to perform static analysis on the code, to determine
  if arguments defined as \emph{in}, \emph{out} or \emph{in/out} are actually used in that
  way, and flagging it up to the user if they are not.
\end{itemize}

\section{Timetable: Workplan and Milestones to be Achieved}

Planned starting date is 18/10/2011.

\begin{enumerate}

\item {\bf Michaelmas week 2 -} Study Doxygen's comment format and
  design new comment format to be used.

\item {\bf Michaelmas week 3 -} Revise parsers and implement a basic
  test one.

\item {\bf Michaelmas weeks 4--6 -} Write a parser to interpret
  appropriately styled comments.

\item {\bf Michaelmas weeks 7--8 -} Write an output module to produce a
  human-readable document from appropriately structured data.

\item {\bf Michaelmas vacation -} Create the main processing module to
  convert from a parse tree into the data structure required by the
  output module.

\item {\bf Lent weeks 0--2 -} Write progress report. Initial testing on
  open-source projects.

\item {\bf Lent weeks 3--5 -} Improvements \& optimisations to code to
  improve user-friendliness of output and process.

\item {\bf Lent weeks 6--8 -} Engine should work by this point; thorough
  testing on large source-trees takes place. Main evaluation with Dr.~Watt's source.

\item {\bf Easter vacation -} Time reserved for fixes and/or possible
  extensions. Main writing of dissertation chapters.

\item {\bf Easter term 0 -} Final proofing \& binding; early submission.

\item {\bf Easter term 1+ -} Revision for examinations.

\end{enumerate}


 

